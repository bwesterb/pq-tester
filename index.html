<html>
    <head>
        <title>PQ tester</title>
        <style>
            body {
              font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
                margin: 0;
                color: #1c1e21;
              }

              #domain  {
                padding: 0.2em;
                width: 400px;
                font-size: larger;
                margin-bottom: 2em;
              }

              #prompt input[type=submit] {
                font-size: larger;
                border: 1px solid gray;
                background-color: orange;
                color: white;
              }

              h1 {
                font-size: 2rem;
                line-height: normal;
              }

              a {
                color: #f38020;
                text-decoration: none;
              }

              #content {
                grid-area: content;
                margin-left: 2rem;
                margin-right: 3rem;
                line-height: 1.5rem;
                z-index: -5;
                max-width: 800px;
              }

              #cresult, #tcp-result, #quic-result, #tresult {
                padding: 1em;
                margin-top: 1em;
                border: 1px solid gray;
              }

              .pq {
                border: 1px solid green;
                background-color: lightgreen;
              }

              .nopq, .error {
                border: 1px solid red;
                background-color: pink;
              }

              .inProgress {
                border: 1px solid yellow;
                background-color: beige;
              }

        </style>
        <script type="text/javascript">
            let kexLut = {
                23: [false, "P-256"],
                24: [false, "P-384"],
                24: [false, "P-521"],
                29: [false, "X25519"],
                65072: [true, "X25519Kyber512Draft00"],
                65073: [true, "X25519Kyber768Draft00Old"],
                65074: [true, "P256Kyber768Draft00"],
                25497: [true, "X25519Kyber768Draft00"],
                4588: [true, "X25519MLKEM768"]
            };

            function addPortToRemote(input) {
                if (input.startsWith('[')) {
                    if(!input.match(/^\[([^\]]+)\]:(\d+)$/)) {
                        return input + ":443";
                    }
                    return input;
                } 

                const colonCount = (input.match(/:/g) || []).length;
                if (colonCount === 1) {
                    const lastColon = input.lastIndexOf(':');
                    const potentialPort = input.substring(lastColon + 1);
                    if (/^\d+$/.test(potentialPort)) {
                        return input;
                    }
                }
                return input + ":443";
            }

            function formatTransportResult(name, r, remote) {
                if (r.Error) {
                    return {className: "error", text: name + ": " + r.Error};
                }
                let pq = false;
                let kex = r.Kex;
                if (r.Kex in kexLut) {
                    pq = kexLut[r.Kex][0];
                    kex = kexLut[r.Kex][1];
                }
                let text;
                if (pq) {
                    text = name + ": " + remote
                        + " supports post-quantum key agreement ("
                        + kex + ".)";
                } else {
                    text = name + ": " + remote
                        + " does not support post-quantum key agreement ("
                        + "negotiated " + kex + " instead.)";
                }
                if (r.MTC) {
                    text += " Served a Merkle Tree Certificate.";
                }
                if (r.TAIs == null) {
                    text += " No TrustAnchorIdentifiers.";
                } else {
                    text += " TAIs: " + JSON.stringify(r.TAIs);
                }
                return {className: pq ? "pq" : "nopq", text: text};
            }

            async function testTransport(transport, remote, resultEl) {
                resultEl.className = "inProgress";
                resultEl.textContent = "testing " + remote + " over " + transport.toUpperCase() + "...";
                const params = URL.parse(window.location.href).searchParams;
                let request = {
                    remote: addPortToRemote(remote),
                    transport: transport,
                };
                if (params.has("insecure"))
                    request.insecure = "true";
                try {
                    const resp = await fetch(document.URL, {
                        method: "POST",
                        headers: {"Content-Type": "application/x-www-form-urlencoded"},
                        body: new URLSearchParams(request),
                    });
                    if (!resp.ok) {
                        resultEl.className = "error";
                        resultEl.textContent = transport.toUpperCase()
                            + ": " + await resp.text();
                        return;
                    }
                    const data = await resp.json();
                    const r = formatTransportResult(
                        transport.toUpperCase(), data, remote);
                    resultEl.className = r.className;
                    resultEl.textContent = r.text;
                } catch(e) {
                    resultEl.className = "error";
                    resultEl.textContent = transport.toUpperCase()
                        + ": " + e.message;
                }
            }

            function doTestRemote() {
                const remote = document.getElementById("domain").value;
                let url = URL.parse(window.location.href);
                url.searchParams.set("remote", remote);
                history.replaceState(null, "", url.toString());
                testTransport("tcp", remote,
                    document.getElementById("tcp-result"));
                testTransport("quic", remote,
                    document.getElementById("quic-result"));
            }

            window.onload = function() {
                const params = URL.parse(window.location.href).searchParams;
                if (!params.has("remote"))
                    return;
                document.getElementById("domain").value = params.get("remote");
                setTimeout(doTestRemote, 0);
            };
        </script>
    </head>
    <body><article id="content">
        <h1>Does your site support post-quantum?</h1>
        <form id="prompt" action="javascript:doTestRemote();">
            <input type="text" placeholder="your-domain.com" id="domain" />
            <input type="submit" value="Test" />
        </form>
        <div id="tcp-result">
            (TCP result will show up here)
        </div>
        <div id="quic-result">
            (QUIC result will show up here)
        </div>

{{if .TLS}}
        <h1>Does your browser support post-quantum?</h1>
        <div id="cresult" class="{{if .ClientPQ}}pq{{else}}nopq{{end}}">
{{if .ClientPQ}}
            Your browser used post-quantum key agreement ({{.ClientKex}})
{{else}}
            Your browser didn't use post-quantum key agreement ({{.ClientKex}})
{{end}}
        </div>
        <div id="tresult">
{{if .TAIs}}
Your browser sent the following TrustAnchorIdentifiers, which might
indicate Merkle Tree Certificates:<br/><code>{{.TAIs}}</code>
{{else}}
        Your browser didn't send any TrustAnchorIdentifiers.
{{end}}
        </div>
{{end}}
    </article></body>
</html>
